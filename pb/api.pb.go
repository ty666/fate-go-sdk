// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api.proto

/*
Package ZMDev_Fate_pb is a generated protocol buffer package.

It is generated from these files:
	api.proto

It has these top-level messages:
	User
	UserID
	UpdatePasswordMsg
	TicketID
	LoginCheckRes
	Unused
	Credential
	AccessToken
	CertificateUpdate
*/
package ZMDev_Fate_pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CertificateType int32

const (
	CertificateType_StudentNum CertificateType = 0
	CertificateType_PhoneNum   CertificateType = 1
	CertificateType_Email      CertificateType = 2
)

var CertificateType_name = map[int32]string{
	0: "StudentNum",
	1: "PhoneNum",
	2: "Email",
}
var CertificateType_value = map[string]int32{
	"StudentNum": 0,
	"PhoneNum":   1,
	"Email":      2,
}

func (x CertificateType) String() string {
	return proto.EnumName(CertificateType_name, int32(x))
}
func (CertificateType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type User struct {
	Account         string          `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	CertificateType CertificateType `protobuf:"varint,3,opt,name=certificate_type,json=certificateType,enum=ZMDev.Fate.pb.CertificateType" json:"certificate_type,omitempty"`
	Password        string          `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *User) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *User) GetCertificateType() CertificateType {
	if m != nil {
		return m.CertificateType
	}
	return CertificateType_StudentNum
}

func (m *User) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type UserID struct {
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *UserID) Reset()                    { *m = UserID{} }
func (m *UserID) String() string            { return proto.CompactTextString(m) }
func (*UserID) ProtoMessage()               {}
func (*UserID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *UserID) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type UpdatePasswordMsg struct {
	UserId      int64  `protobuf:"varint,1,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	NewPassword string `protobuf:"bytes,2,opt,name=new_password,json=newPassword" json:"new_password,omitempty"`
}

func (m *UpdatePasswordMsg) Reset()                    { *m = UpdatePasswordMsg{} }
func (m *UpdatePasswordMsg) String() string            { return proto.CompactTextString(m) }
func (*UpdatePasswordMsg) ProtoMessage()               {}
func (*UpdatePasswordMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UpdatePasswordMsg) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UpdatePasswordMsg) GetNewPassword() string {
	if m != nil {
		return m.NewPassword
	}
	return ""
}

type TicketID struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *TicketID) Reset()                    { *m = TicketID{} }
func (m *TicketID) String() string            { return proto.CompactTextString(m) }
func (*TicketID) ProtoMessage()               {}
func (*TicketID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *TicketID) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type LoginCheckRes struct {
	IsLogin bool  `protobuf:"varint,1,opt,name=is_login,json=isLogin" json:"is_login,omitempty"`
	UserId  int64 `protobuf:"varint,2,opt,name=user_id,json=userId" json:"user_id,omitempty"`
}

func (m *LoginCheckRes) Reset()                    { *m = LoginCheckRes{} }
func (m *LoginCheckRes) String() string            { return proto.CompactTextString(m) }
func (*LoginCheckRes) ProtoMessage()               {}
func (*LoginCheckRes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *LoginCheckRes) GetIsLogin() bool {
	if m != nil {
		return m.IsLogin
	}
	return false
}

func (m *LoginCheckRes) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type Unused struct {
}

func (m *Unused) Reset()                    { *m = Unused{} }
func (m *Unused) String() string            { return proto.CompactTextString(m) }
func (*Unused) ProtoMessage()               {}
func (*Unused) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type Credential struct {
	AppId     int32  `protobuf:"varint,1,opt,name=app_id,json=appId" json:"app_id,omitempty"`
	AppSecret string `protobuf:"bytes,2,opt,name=app_secret,json=appSecret" json:"app_secret,omitempty"`
}

func (m *Credential) Reset()                    { *m = Credential{} }
func (m *Credential) String() string            { return proto.CompactTextString(m) }
func (*Credential) ProtoMessage()               {}
func (*Credential) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Credential) GetAppId() int32 {
	if m != nil {
		return m.AppId
	}
	return 0
}

func (m *Credential) GetAppSecret() string {
	if m != nil {
		return m.AppSecret
	}
	return ""
}

type AccessToken struct {
	Token     string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	ExpiredAt int64  `protobuf:"varint,2,opt,name=expired_at,json=expiredAt" json:"expired_at,omitempty"`
}

func (m *AccessToken) Reset()                    { *m = AccessToken{} }
func (m *AccessToken) String() string            { return proto.CompactTextString(m) }
func (*AccessToken) ProtoMessage()               {}
func (*AccessToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *AccessToken) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AccessToken) GetExpiredAt() int64 {
	if m != nil {
		return m.ExpiredAt
	}
	return 0
}

type CertificateUpdate struct {
	// int64 id = 1;
	// int64 user_id = 2;
	Account         string          `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	NewAccount      string          `protobuf:"bytes,2,opt,name=newAccount" json:"newAccount,omitempty"`
	CertificateType CertificateType `protobuf:"varint,3,opt,name=certificate_type,json=certificateType,enum=ZMDev.Fate.pb.CertificateType" json:"certificate_type,omitempty"`
}

func (m *CertificateUpdate) Reset()                    { *m = CertificateUpdate{} }
func (m *CertificateUpdate) String() string            { return proto.CompactTextString(m) }
func (*CertificateUpdate) ProtoMessage()               {}
func (*CertificateUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CertificateUpdate) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *CertificateUpdate) GetNewAccount() string {
	if m != nil {
		return m.NewAccount
	}
	return ""
}

func (m *CertificateUpdate) GetCertificateType() CertificateType {
	if m != nil {
		return m.CertificateType
	}
	return CertificateType_StudentNum
}

func init() {
	proto.RegisterType((*User)(nil), "ZMDev.Fate.pb.User")
	proto.RegisterType((*UserID)(nil), "ZMDev.Fate.pb.UserID")
	proto.RegisterType((*UpdatePasswordMsg)(nil), "ZMDev.Fate.pb.UpdatePasswordMsg")
	proto.RegisterType((*TicketID)(nil), "ZMDev.Fate.pb.TicketID")
	proto.RegisterType((*LoginCheckRes)(nil), "ZMDev.Fate.pb.LoginCheckRes")
	proto.RegisterType((*Unused)(nil), "ZMDev.Fate.pb.Unused")
	proto.RegisterType((*Credential)(nil), "ZMDev.Fate.pb.Credential")
	proto.RegisterType((*AccessToken)(nil), "ZMDev.Fate.pb.AccessToken")
	proto.RegisterType((*CertificateUpdate)(nil), "ZMDev.Fate.pb.CertificateUpdate")
	proto.RegisterEnum("ZMDev.Fate.pb.CertificateType", CertificateType_name, CertificateType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AccessTokenService service

type AccessTokenServiceClient interface {
	// 获取 access token
	Token(ctx context.Context, in *Credential, opts ...grpc.CallOption) (*AccessToken, error)
}

type accessTokenServiceClient struct {
	cc *grpc.ClientConn
}

func NewAccessTokenServiceClient(cc *grpc.ClientConn) AccessTokenServiceClient {
	return &accessTokenServiceClient{cc}
}

func (c *accessTokenServiceClient) Token(ctx context.Context, in *Credential, opts ...grpc.CallOption) (*AccessToken, error) {
	out := new(AccessToken)
	err := grpc.Invoke(ctx, "/ZMDev.Fate.pb.AccessTokenService/Token", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AccessTokenService service

type AccessTokenServiceServer interface {
	// 获取 access token
	Token(context.Context, *Credential) (*AccessToken, error)
}

func RegisterAccessTokenServiceServer(s *grpc.Server, srv AccessTokenServiceServer) {
	s.RegisterService(&_AccessTokenService_serviceDesc, srv)
}

func _AccessTokenService_Token_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credential)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccessTokenServiceServer).Token(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ZMDev.Fate.pb.AccessTokenService/Token",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccessTokenServiceServer).Token(ctx, req.(*Credential))
	}
	return interceptor(ctx, in, info, handler)
}

var _AccessTokenService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ZMDev.Fate.pb.AccessTokenService",
	HandlerType: (*AccessTokenServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Token",
			Handler:    _AccessTokenService_Token_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// Client API for CertificateService service

type CertificateServiceClient interface {
	Update(ctx context.Context, in *CertificateUpdate, opts ...grpc.CallOption) (*Unused, error)
}

type certificateServiceClient struct {
	cc *grpc.ClientConn
}

func NewCertificateServiceClient(cc *grpc.ClientConn) CertificateServiceClient {
	return &certificateServiceClient{cc}
}

func (c *certificateServiceClient) Update(ctx context.Context, in *CertificateUpdate, opts ...grpc.CallOption) (*Unused, error) {
	out := new(Unused)
	err := grpc.Invoke(ctx, "/ZMDev.Fate.pb.CertificateService/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CertificateService service

type CertificateServiceServer interface {
	Update(context.Context, *CertificateUpdate) (*Unused, error)
}

func RegisterCertificateServiceServer(s *grpc.Server, srv CertificateServiceServer) {
	s.RegisterService(&_CertificateService_serviceDesc, srv)
}

func _CertificateService_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CertificateUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CertificateServiceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ZMDev.Fate.pb.CertificateService/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CertificateServiceServer).Update(ctx, req.(*CertificateUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

var _CertificateService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ZMDev.Fate.pb.CertificateService",
	HandlerType: (*CertificateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Update",
			Handler:    _CertificateService_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// Client API for LoginChecker service

type LoginCheckerClient interface {
	Check(ctx context.Context, in *TicketID, opts ...grpc.CallOption) (*LoginCheckRes, error)
	Logout(ctx context.Context, in *TicketID, opts ...grpc.CallOption) (*Unused, error)
}

type loginCheckerClient struct {
	cc *grpc.ClientConn
}

func NewLoginCheckerClient(cc *grpc.ClientConn) LoginCheckerClient {
	return &loginCheckerClient{cc}
}

func (c *loginCheckerClient) Check(ctx context.Context, in *TicketID, opts ...grpc.CallOption) (*LoginCheckRes, error) {
	out := new(LoginCheckRes)
	err := grpc.Invoke(ctx, "/ZMDev.Fate.pb.LoginChecker/Check", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *loginCheckerClient) Logout(ctx context.Context, in *TicketID, opts ...grpc.CallOption) (*Unused, error) {
	out := new(Unused)
	err := grpc.Invoke(ctx, "/ZMDev.Fate.pb.LoginChecker/Logout", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for LoginChecker service

type LoginCheckerServer interface {
	Check(context.Context, *TicketID) (*LoginCheckRes, error)
	Logout(context.Context, *TicketID) (*Unused, error)
}

func RegisterLoginCheckerServer(s *grpc.Server, srv LoginCheckerServer) {
	s.RegisterService(&_LoginChecker_serviceDesc, srv)
}

func _LoginChecker_Check_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginCheckerServer).Check(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ZMDev.Fate.pb.LoginChecker/Check",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginCheckerServer).Check(ctx, req.(*TicketID))
	}
	return interceptor(ctx, in, info, handler)
}

func _LoginChecker_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TicketID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LoginCheckerServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ZMDev.Fate.pb.LoginChecker/Logout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LoginCheckerServer).Logout(ctx, req.(*TicketID))
	}
	return interceptor(ctx, in, info, handler)
}

var _LoginChecker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ZMDev.Fate.pb.LoginChecker",
	HandlerType: (*LoginCheckerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Check",
			Handler:    _LoginChecker_Check_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _LoginChecker_Logout_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// Client API for UserService service

type UserServiceClient interface {
	// todo update password
	UpdatePassword(ctx context.Context, in *UpdatePasswordMsg, opts ...grpc.CallOption) (*Unused, error)
	Register(ctx context.Context, in *User, opts ...grpc.CallOption) (*UserID, error)
}

type userServiceClient struct {
	cc *grpc.ClientConn
}

func NewUserServiceClient(cc *grpc.ClientConn) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) UpdatePassword(ctx context.Context, in *UpdatePasswordMsg, opts ...grpc.CallOption) (*Unused, error) {
	out := new(Unused)
	err := grpc.Invoke(ctx, "/ZMDev.Fate.pb.UserService/UpdatePassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) Register(ctx context.Context, in *User, opts ...grpc.CallOption) (*UserID, error) {
	out := new(UserID)
	err := grpc.Invoke(ctx, "/ZMDev.Fate.pb.UserService/Register", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for UserService service

type UserServiceServer interface {
	// todo update password
	UpdatePassword(context.Context, *UpdatePasswordMsg) (*Unused, error)
	Register(context.Context, *User) (*UserID, error)
}

func RegisterUserServiceServer(s *grpc.Server, srv UserServiceServer) {
	s.RegisterService(&_UserService_serviceDesc, srv)
}

func _UserService_UpdatePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePasswordMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdatePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ZMDev.Fate.pb.UserService/UpdatePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdatePassword(ctx, req.(*UpdatePasswordMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ZMDev.Fate.pb.UserService/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).Register(ctx, req.(*User))
	}
	return interceptor(ctx, in, info, handler)
}

var _UserService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ZMDev.Fate.pb.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdatePassword",
			Handler:    _UserService_UpdatePassword_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _UserService_Register_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func init() { proto.RegisterFile("api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 552 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0xc1, 0x6f, 0xda, 0x3e,
	0x14, 0xc7, 0x09, 0xfd, 0x91, 0x26, 0xaf, 0x94, 0x52, 0xff, 0x56, 0x95, 0x46, 0x5b, 0xc5, 0x7c,
	0xaa, 0x76, 0xe0, 0xc0, 0x2e, 0x53, 0x4f, 0xa3, 0x74, 0x93, 0xd0, 0xda, 0xad, 0x0a, 0x30, 0x69,
	0xbb, 0x20, 0xd7, 0x79, 0xa3, 0x16, 0x34, 0xb1, 0x6c, 0xa7, 0xac, 0x7f, 0xc1, 0x2e, 0x3b, 0xee,
	0xb0, 0x3f, 0x77, 0x4a, 0x48, 0x68, 0x08, 0x62, 0xa7, 0xdd, 0xfc, 0x9e, 0xbf, 0x7e, 0xef, 0xe3,
	0xe7, 0xf7, 0x0c, 0x2e, 0x93, 0xa2, 0x23, 0x55, 0x64, 0x22, 0xb2, 0xff, 0xf5, 0xfa, 0x12, 0x1f,
	0x3a, 0xef, 0x99, 0xc1, 0x8e, 0xbc, 0xa5, 0x3f, 0x2c, 0xf8, 0x6f, 0xac, 0x51, 0x91, 0x16, 0xec,
	0x32, 0xce, 0xa3, 0x38, 0x34, 0x2d, 0xab, 0x6d, 0x9d, 0xb9, 0x7e, 0x6e, 0x92, 0x01, 0x34, 0x39,
	0x2a, 0x23, 0xbe, 0x09, 0xce, 0x0c, 0x4e, 0xcc, 0xa3, 0xc4, 0xd6, 0x4e, 0xdb, 0x3a, 0x6b, 0x74,
	0x4f, 0x3b, 0x6b, 0xc1, 0x3a, 0xfd, 0x27, 0xd9, 0xe8, 0x51, 0xa2, 0x7f, 0xc0, 0xd7, 0x1d, 0xc4,
	0x03, 0x47, 0x32, 0xad, 0x17, 0x91, 0x0a, 0x5a, 0xd5, 0x34, 0xcb, 0xca, 0xa6, 0x2d, 0xb0, 0x13,
	0x90, 0xc1, 0x25, 0x69, 0x40, 0x55, 0x04, 0x29, 0xc5, 0x8e, 0x5f, 0x15, 0x01, 0xfd, 0x04, 0x87,
	0x63, 0x19, 0x30, 0x83, 0x37, 0x99, 0xf6, 0x5a, 0x4f, 0xc9, 0x31, 0xec, 0xc6, 0x1a, 0xd5, 0x64,
	0xa5, 0xb4, 0x13, 0x73, 0x10, 0x90, 0x97, 0x50, 0x0f, 0x71, 0x31, 0x29, 0xe5, 0xd9, 0x0b, 0x71,
	0x91, 0x1f, 0xa7, 0x1e, 0x38, 0x23, 0xc1, 0x67, 0x68, 0xd6, 0x92, 0xb9, 0x69, 0xb2, 0x3e, 0xec,
	0x5f, 0x45, 0x53, 0x11, 0xf6, 0xef, 0x90, 0xcf, 0x7c, 0xd4, 0xe4, 0x04, 0x1c, 0xa1, 0x27, 0xf3,
	0xc4, 0x97, 0xca, 0x1c, 0x7f, 0x57, 0xe8, 0x54, 0x52, 0x64, 0xa8, 0x16, 0x19, 0xa8, 0x03, 0xf6,
	0x38, 0x8c, 0x35, 0x06, 0xf4, 0x02, 0xa0, 0xaf, 0x30, 0xc0, 0xd0, 0x08, 0x36, 0x27, 0x47, 0x60,
	0x33, 0x29, 0x73, 0xe6, 0x9a, 0x5f, 0x63, 0x52, 0x0e, 0x02, 0xf2, 0x02, 0x20, 0x71, 0x6b, 0xe4,
	0x0a, 0x4d, 0x06, 0xec, 0x32, 0x29, 0x87, 0xa9, 0x83, 0x5e, 0xc0, 0x5e, 0x8f, 0x73, 0xd4, 0x7a,
	0x14, 0xcd, 0x30, 0x24, 0xcf, 0xa0, 0x66, 0x92, 0x45, 0x06, 0xbd, 0x34, 0x92, 0x18, 0xf8, 0x5d,
	0x0a, 0x85, 0xc1, 0x84, 0x99, 0x0c, 0xc7, 0xcd, 0x3c, 0x3d, 0x43, 0x7f, 0x5b, 0x70, 0x58, 0x78,
	0x9e, 0x65, 0x3d, 0xff, 0xf2, 0xe8, 0xa7, 0x00, 0x21, 0x2e, 0x7a, 0xd9, 0xe6, 0x12, 0xa9, 0xe0,
	0xf9, 0x87, 0x4d, 0xf1, 0xea, 0x1c, 0x0e, 0x4a, 0x1a, 0xd2, 0x00, 0x18, 0x9a, 0x38, 0xa9, 0xda,
	0xc7, 0xf8, 0xbe, 0x59, 0x21, 0x75, 0x70, 0x6e, 0xee, 0xa2, 0x10, 0x13, 0xcb, 0x22, 0x2e, 0xd4,
	0xde, 0xdd, 0x33, 0x31, 0x6f, 0x56, 0xbb, 0x9f, 0x81, 0x14, 0x4a, 0x33, 0x44, 0xf5, 0x20, 0x38,
	0x92, 0xb7, 0x50, 0x5b, 0x96, 0xea, 0xa4, 0xcc, 0xb2, 0x7a, 0x0a, 0xcf, 0x2b, 0x6d, 0x15, 0xc2,
	0xd0, 0x4a, 0xf7, 0x0b, 0x90, 0x02, 0x53, 0x1e, 0xb7, 0x0f, 0x76, 0x56, 0xb8, 0xf6, 0xf6, 0x4b,
	0x2e, 0x15, 0xde, 0x51, 0x49, 0x91, 0xf5, 0x43, 0xa5, 0xfb, 0xd3, 0x82, 0xfa, 0x53, 0x87, 0xa1,
	0x4a, 0x68, 0xd3, 0x25, 0x39, 0x2e, 0x1d, 0xc9, 0x7b, 0xd4, 0x7b, 0x5e, 0xda, 0x58, 0x6b, 0x50,
	0x5a, 0x21, 0xe7, 0x60, 0x5f, 0x45, 0xd3, 0x28, 0x36, 0xdb, 0x43, 0x6c, 0xc5, 0xf9, 0x65, 0xc1,
	0x5e, 0x32, 0x77, 0xf9, 0x1d, 0x3f, 0x40, 0x63, 0x7d, 0xd8, 0x36, 0xee, 0xba, 0x31, 0x8b, 0x5b,
	0x83, 0x93, 0x37, 0xe0, 0xf8, 0x38, 0x15, 0xda, 0xa0, 0x22, 0xff, 0x97, 0x45, 0x1a, 0xd5, 0xe6,
	0xc9, 0xf4, 0x07, 0xa0, 0x95, 0x5b, 0x3b, 0xfd, 0xad, 0x5e, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff,
	0x49, 0x0e, 0xf4, 0x1b, 0xba, 0x04, 0x00, 0x00,
}
